%name Muml;

%defs (
  structure A = Ast
);

%tokens
  : KW_let ("let") | KW_in ("in") | KW_end ("end")
  | KW_fn ("fn") | KW_fun ("fun") | KW_val ("val")
  | KW_if ("if") | KW_then ("then") | KW_else ("else")
  | KW_andalso ("andalso") | KW_orelse ("orelse")
  | CON_int of Int.int | CON_string of string
  | ID of string | OP of string
  | LP ("(") | RP (")") | COMMA (",") | SEMI (";")| COLON (":")
  | LB ("[") | RB ("]")
  | ARROW ("=>") | TARROW ("->")
  ;

exp
  : %try simpleExp OP simpleExp => ( A.InfixApp(simpleExp1, OP, simpleExp2) )
  | %try simpleExp simpleExp => ( A.App(simpleExp1, simpleExp2) )
  | %try simpleExp
  ;

simpleExp
  : CON_int => ( A.IntConstant(CON_int) )
  | ID => ( A.Variable(ID) )
  | KW_if exp KW_then exp KW_else exp => ( A.IfThenElse(exp1, exp2, exp3) )
  | KW_fn fnArgs ARROW exp => ( A.Fn(fnArgs, exp) )
  | KW_let dec KW_in exp KW_end => ( A.LetIn([dec], exp) )
  | LP exp RP => ( exp )
  ;

fnArgs
  : LP arglist? RP => ( (case arglist of SOME(l) => l | NONE => []) )
  | ID => ( [A.Name(ID)] )
  ;

arglist
  : ID (COMMA ID)* => ( [A.Name(ID)] )
  ;

dec
  : KW_val valdec
  ;

valdec
  : ID OP exp %where ( OP = "=" ) => ( A.Valdec(A.Name(ID), exp) )
  ;
