%name Muml;

%defs (
  structure A = Ast
);

%tokens
  : KW_let ("let") | KW_in ("in") | KW_end ("end")
  | KW_fn ("fn") | KW_fun ("fun") | KW_val ("val")
  | KW_if ("if") | KW_then ("then") | KW_else ("else")
  | KW_andalso ("andalso") | KW_orelse ("orelse")
  | CON_int of Int.int | CON_string of string
  | ID of string | OP of string
  | LP ("(") | RP (")") | COMMA (",") | SEMI (";")| COLON (":")
  | LB ("[") | RB ("]")
  | ARROW ("=>") | TARROW ("->")
  ;

%start exp;

explist
  : %try exp COMMA explist => ( exp :: explist )
  | %try exp => ( [exp] )
  ;

expsequence
  : %try appExp SEMI expsequence => ( appExp :: expsequence )
  | %try appExp => ( [appExp] )
  ;

exp
  : %try opExp SEMI expsequence => ( A.Sequence(opExp :: expsequence) )
  | %try opExp
  ;

opExp
  : %try appExp OP appExp => ( A.InfixApp(appExp1, OP, appExp2) )
  | %try appExp
  ;

appExp
  : %try simpleExp simpleExp => ( A.App(simpleExp1, simpleExp2) )
  | %try simpleExp
  ;

simpleExp
  : CON_int => ( A.IntConstant(CON_int) )
  | CON_string => ( A.StringConstant(CON_string) )
  | ID => ( A.Variable(ref (A.create_symbol ID)) )
  | KW_if exp KW_then exp KW_else exp => ( A.IfThenElse(exp1, exp2, exp3) )
  | KW_fn fnArgs ARROW exp => ( A.Fn(fnArgs, exp) )
  | KW_let declist KW_in exp KW_end => ( A.LetIn(declist, exp) )
  | %try LP exp RP => ( exp )
  | %try LP exp COMMA explist RP => ( A.Tuple(exp :: explist) )
  | LP RP => ( A.Unit )
  ;

fnArgs
  : LP RP => ( [] )
  | LP arglist RP => ( arglist )
  | ID => ( [A.Name(ref (A.create_symbol ID))] )
  ;

arglist
  : %try ID COMMA arglist => ( A.Name(ref (A.create_symbol ID)) :: arglist )
  | %try ID => ( [A.Name(ref (A.create_symbol ID))] )
  ;

declist
  : %try dec SEMI declist => ( dec :: declist )
  | %try dec => ( [dec] )
  ;

dec
  : KW_val valdec
  | KW_fun fundec
  ;

valdec
  : ID OP exp %where ( OP = "=" ) => ( A.Valdec(A.Name(ref (A.create_symbol ID)), exp) )
  ;

fundec
  : ID fnArgs OP exp %where ( OP = "=" ) => ( A.Fundec(A.Name(ref (A.create_symbol ID)), A.Fn(fnArgs, exp)) )
  ;
